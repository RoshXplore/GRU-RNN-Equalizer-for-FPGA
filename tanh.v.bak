`timescale 1ns / 1ps

module tanh (
    input clk,
    input rstn,
    input start,
    input [31:0] in_fp,
    output reg [31:0] out_fp,
    output reg done
);

    // --- Constants for piecewise approximation ---
    localparam [31:0] P_ONE = 32'h3F800000, N_ONE = 32'hBF800000;
    localparam [31:0] P_3_0 = 32'h40400000, N_3_0 = 32'hC0400000;
    // ... other constants ...

    // --- FSM ---
    reg [1:0] state, next_state;
    localparam S_IDLE        = 2'd0,
               S_APPROXIMATE = 2'd1,
               S_WAIT_ADD    = 2'd2,
               S_DONE        = 2'd3;

    // --- Internal Signals ---
    reg [31:0] approx_result_reg;
    reg [31:0] adder_bias_reg;
    reg needs_addition_reg;
    reg adder_start;
    wire adder_done;
    wire [31:0] adder_result_wire;

    // --- Instantiate Handshake-Based Adder ---
    adder adder_inst (
        .clk(clk), .rstn(rstn),
        .start(adder_start),
        .done(adder_done),
        .value_in(approx_result_reg),
        .bias(adder_bias_reg),
        .value_out(adder_result_wire)
    );

    // --- Sequential Logic ---
    always @(posedge clk or negedge rstn) begin
        if (!rstn) begin
            state <= S_IDLE;
            out_fp <= 0;
            done <= 1'b0;
            adder_start <= 1'b0;
        end else begin
            state <= next_state;
            done <= (next_state == S_DONE);

            // Pulse the adder start signal for one cycle
            adder_start <= (next_state == S_WAIT_ADD && state == S_APPROXIMATE);

            // Perform initial approximation
            if (state == S_IDLE && next_state == S_APPROXIMATE) begin
                // ... (approximation logic is the same as your original) ...
                if ($signed(in_fp) < $signed(N_3_0)) begin
                    needs_addition_reg <= 1'b0; out_fp <= N_ONE;
                end else if ($signed(in_fp) > $signed(P_3_0)) begin
                    needs_addition_reg <= 1'b0; out_fp <= P_ONE;
                end else begin // Cases that need the adder
                    needs_addition_reg <= 1'b1;
                    // ... set approx_result_reg and adder_bias_reg ...
                end
            end

            // Latch the final result from the adder
            if (state == S_WAIT_ADD && adder_done) begin
                out_fp <= adder_result_wire;
            end
        end
    end

    // --- Combinational FSM Logic ---
    always @(*) begin
        next_state = state;
        case (state)
            S_IDLE:
                if (start) next_state = S_APPROXIMATE;
            S_APPROXIMATE:
                if (needs_addition_reg)
                    next_state = S_WAIT_ADD;
                else
                    next_state = S_DONE;
            S_WAIT_ADD:
                if (adder_done) next_state = S_DONE;
            S_DONE:
                if (!start) next_state = S_IDLE;
        endcase
    end
endmodule
