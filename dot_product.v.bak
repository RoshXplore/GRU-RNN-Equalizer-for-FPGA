`timescale 1ns / 1ps

module dot_product #(
    parameter DATA_WIDTH = 32,
    parameter MAX_VECTOR_SIZE = 7
)(
    input clk,
    input rstn,
    input start,
    output reg done,

    input [DATA_WIDTH*MAX_VECTOR_SIZE-1:0] vector_a_flat,
    input [DATA_WIDTH*MAX_VECTOR_SIZE-1:0] vector_b_flat,
    input [3:0] vector_length,
    output reg [DATA_WIDTH-1:0] result
);

    // --- FSM States ---
    reg [2:0] state, next_state;
    localparam S_IDLE = 3'd0, S_START_MAC = 3'd1, S_WAIT_MAC = 3'd2, S_DONE = 3'd3;

    // --- Internal Signals ---
    reg [$clog2(MAX_VECTOR_SIZE):0] index;
    reg [DATA_WIDTH-1:0] partial_sum;
    reg [DATA_WIDTH-1:0] current_a, current_b;
    reg mult_start, add_start;
    wire mult_done, add_done;
    wire [DATA_WIDTH-1:0] mult_out, add_out;

    // --- Instantiate Handshake-Based Workers ---
    multiplier u_multiplier (
        .clk(clk), .rstn(rstn), .start(mult_start), .done(mult_done),
        .w(current_a), .x(current_b), .mult_result(mult_out)
    );
    adder u_adder (
        .clk(clk), .rstn(rstn), .start(add_start), .done(add_done),
        .value_in(mult_out), .bias(partial_sum), .value_out(add_out)
    );

    // --- Sequential Logic ---
    always @(posedge clk or negedge rstn) begin
        if (!rstn) begin
            state <= S_IDLE;
            done <= 1'b0;
            index <= 0;
            partial_sum <= 0;
            result <= 0;
            mult_start <= 1'b0;
            add_start <= 1'b0;
        end else begin
            state <= next_state;
            done <= (next_state == S_DONE);

            // Pulse start signals
            mult_start <= (next_state == S_START_MAC);
            add_start <= (next_state == S_START_MAC);

            // Latch inputs for the current operation
            if (next_state == S_START_MAC) begin
                index <= (state == S_WAIT_MAC) ? index + 1 : 0;
                current_a <= vector_a_flat[((state == S_WAIT_MAC) ? index + 1 : 0)*DATA_WIDTH +: DATA_WIDTH];
                current_b <= vector_b_flat[((state == S_WAIT_MAC) ? index + 1 : 0)*DATA_WIDTH +: DATA_WIDTH];
                if (state == S_IDLE) partial_sum <= 0;
            end
            
            // When the MAC operation is done, latch the new sum
            if (state == S_WAIT_MAC && next_state != S_WAIT_MAC) begin
                partial_sum <= add_out;
            end
            
            // Latch the final result
            if (next_state == S_DONE) begin
                result <= partial_sum;
            end
        end
    end

    // --- Combinational FSM Logic ---
    always @(*) begin
        next_state = state;
        case(state)
            S_IDLE:
                if (start) next_state = S_START_MAC;
            S_START_MAC:
                next_state = S_WAIT_MAC;
            S_WAIT_MAC:
                // Handshake: Wait for both workers to be done
                if (mult_done && add_done) begin
                    if (index == vector_length - 1) begin
                        next_state = S_DONE;
                    end else begin
                        next_state = S_START_MAC; // Loop back for next element
                    end
                end
            S_DONE:
                if (!start) next_state = S_IDLE;
        endcase
    end
endmodule