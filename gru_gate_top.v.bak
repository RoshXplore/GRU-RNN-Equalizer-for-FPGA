`timescale 1ns / 1ps

module gru_gate_top #(
    parameter DATA_WIDTH = 32,
    parameter GRU_UNITS = 7,
    parameter INPUT_FEATURES = 3
)(
    // Simple, narrow interface for the outside world
    input clk,
    input rstn,
    input start_process,
    output reg done_process,

    // Interface for loading data into internal memories
    input [DATA_WIDTH-1:0] i_data,
    input [7:0] i_addr,
    input i_we,

    // Configuration and final result
    input i_activation_type,
    output [DATA_WIDTH-1:0] o_result
);

    // --- Internal On-Chip Memories ---
    // These will be synthesized into Block RAM
    reg [DATA_WIDTH-1:0] w_weights_mem [0:INPUT_FEATURES-1];
    reg [DATA_WIDTH-1:0] u_weights_mem [0:GRU_UNITS-1];
    reg [DATA_WIDTH-1:0] input_vector_mem [0:INPUT_FEATURES-1];
    reg [DATA_WIDTH-1:0] hidden_vector_mem [0:GRU_UNITS-1];
    reg [DATA_WIDTH-1:0] bias_reg;

    // --- Memory Write Logic ---
    // A simple memory map to load all the required data.
    // Address bits [7:6] select the memory block.
    // Address bits [3:0] select the word within the block.
    always @(posedge clk) begin
        if (i_we) begin
            case (i_addr[7:6])
                2'b00: w_weights_mem[i_addr[3:0]] <= i_data;
                2'b01: u_weights_mem[i_addr[3:0]] <= i_data;
                2'b10: input_vector_mem[i_addr[3:0]] <= i_data;
                2'b11: hidden_vector_mem[i_addr[3:0]] <= i_data;
                default:; // Default case
            endcase
            // A specific address for the single bias value
            if (i_addr == 8'hF0) begin
                bias_reg <= i_data;
            end
        end
    end

    // --- Data Flattening ---
    // The gate_cal module needs flat vectors. This logic packs the
    // data from our memories into the required format.
    genvar i, j, k, l;
    wire [(INPUT_FEATURES * DATA_WIDTH)-1:0] w_weights_flat_wire;
    wire [(GRU_UNITS * DATA_WIDTH)-1:0]      u_weights_flat_wire;
    wire [(INPUT_FEATURES * DATA_WIDTH)-1:0] input_vector_flat_wire;
    wire [(GRU_UNITS * DATA_WIDTH)-1:0]      hidden_vector_flat_wire;

    generate
        for (i = 0; i < INPUT_FEATURES; i = i + 1) begin : w_pack
            assign w_weights_flat_wire[(i+1)*DATA_WIDTH-1 : i*DATA_WIDTH] = w_weights_mem[i];
        end
        for (j = 0; j < GRU_UNITS; j = j + 1) begin : u_pack
            assign u_weights_flat_wire[(j+1)*DATA_WIDTH-1 : j*DATA_WIDTH] = u_weights_mem[j];
        end
        for (k = 0; k < INPUT_FEATURES; k = k + 1) begin : x_pack
            assign input_vector_flat_wire[(k+1)*DATA_WIDTH-1 : k*DATA_WIDTH] = input_vector_mem[k];
        end
        for (l = 0; l < GRU_UNITS; l = l + 1) begin : h_pack
            assign hidden_vector_flat_wire[(l+1)*DATA_WIDTH-1 : l*DATA_WIDTH] = hidden_vector_mem[l];
        end
    endgenerate

    // --- FSM and gate_cal Control ---
    reg [1:0] state;
    localparam S_IDLE    = 2'd0,
               S_COMPUTE = 2'd1,
               S_DONE    = 2'd2;

    reg gate_cal_start;
    wire gate_cal_done;

    always @(posedge clk or negedge rstn) begin
        if (!rstn) begin
            state <= S_IDLE;
            gate_cal_start <= 1'b0;
            done_process <= 1'b0;
        end else begin
            // Default assignments
            gate_cal_start <= 1'b0;
            done_process <= 1'b0;
            
            case(state)
                S_IDLE: begin
                    if (start_process) begin
                        gate_cal_start <= 1'b1; // Start the internal worker
                        state <= S_COMPUTE;
                    end
                end
                S_COMPUTE: begin
                    if (gate_cal_done) begin
                        state <= S_DONE;
                    end
                end
                S_DONE: begin
                    done_process <= 1'b1; // Signal completion to the outside world
                    state <= S_IDLE;
                end
                default: state <= S_IDLE;
            endcase
        end
    end
    
    // --- Instantiate the gate_cal Worker Module ---
    gate_cal #(
        .DATA_WIDTH(DATA_WIDTH),
        .GRU_UNITS(GRU_UNITS),
        .INPUT_FEATURES(INPUT_FEATURES)
    ) u_gate_cal (
        .clk(clk),
        .rstn(rstn),
        .start(gate_cal_start),
        .done(gate_cal_done),
        .activation_type(i_activation_type),
        .i_input_vector_flat(input_vector_flat_wire),
        .i_hidden_vector_flat(hidden_vector_flat_wire),
        .i_W_weights_flat(w_weights_flat_wire),
        .i_U_weights_flat(u_weights_flat_wire),
        .bias(bias_reg),
        .gate_result(o_result)
    );

endmodule