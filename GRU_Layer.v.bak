`timescale 1ns / 1ps

module GRU_Layer #(
    parameter DATA_WIDTH      = 32,
    parameter GRU_UNITS       = 3, // Changed from 7
    parameter INPUT_FEATURES  = 3
)(
    input  wire clk,
    input  wire rstn,
    input  wire i_start, // Single start signal for the entire layer
    output reg  o_done,  // Single done signal for the entire layer

    // --- Inputs ---
    input  wire [(INPUT_FEATURES*DATA_WIDTH)-1:0]           i_input_vector_flat,
    input  wire [(GRU_UNITS*DATA_WIDTH)-1:0]                i_prev_hidden_state_flat,
    // Weight matrices and bias vectors, flattened
    input  wire [(GRU_UNITS*INPUT_FEATURES*DATA_WIDTH)-1:0] i_Wr_flat,
    input  wire [(GRU_UNITS*GRU_UNITS*DATA_WIDTH)-1:0]      i_Ur_flat,
    input  wire [(GRU_UNITS*DATA_WIDTH)-1:0]                i_br_flat,
    input  wire [(GRU_UNITS*INPUT_FEATURES*DATA_WIDTH)-1:0] i_Wz_flat,
    input  wire [(GRU_UNITS*GRU_UNITS*DATA_WIDTH)-1:0]      i_Uz_flat,
    input  wire [(GRU_UNITS*DATA_WIDTH)-1:0]                i_bz_flat,
    input  wire [(GRU_UNITS*INPUT_FEATURES*DATA_WIDTH)-1:0] i_Wh_flat,
    input  wire [(GRU_UNITS*GRU_UNITS*DATA_WIDTH)-1:0]      i_Uh_flat,
    input  wire [(GRU_UNITS*DATA_WIDTH)-1:0]                i_bh_flat,

    // --- Output ---
    output wire [(GRU_UNITS*DATA_WIDTH)-1:0] o_new_hidden_state_flat
);

    // --- State Machine ---
    localparam S_IDLE = 2'd0,
               S_CALC = 2'd1,
               S_WAIT = 2'd2,
               S_DONE = 2'd3;
    reg [1:0] state, next_state;

    // --- Control Signals for GRU_Cells ---
    reg start_cells;
    wire [GRU_UNITS-1:0] cells_done; // Collect done signals from all cells

    // --- Generate GRU_Cell Workers ---
    // This part is correct and instantiates one cell for each unit in the layer.
    genvar g;
    generate
        for (g = 0; g < GRU_UNITS; g = g + 1) begin : gru_unit_workers
            GRU_Cell #(
                .DATA_WIDTH(DATA_WIDTH),
                .GRU_UNITS(GRU_UNITS),
                .INPUT_FEATURES(INPUT_FEATURES)
            ) worker (
                .clk(clk), .rstn(rstn),
                .i_start_cell(start_cells), // All cells get the same start signal
                .o_done_cell(cells_done[g]), // Each cell has its own done output

                // Pass the full input and previous hidden state vectors to all cells
                .i_input_vector_flat(i_input_vector_flat),
                .i_prev_hidden_state_flat(i_prev_hidden_state_flat),

                // Slice the weight matrices to pass the correct row to each cell
                .i_Wr_flat(i_Wr_flat[g*INPUT_FEATURES*DATA_WIDTH +: INPUT_FEATURES*DATA_WIDTH]),
                .i_Ur_flat(i_Ur_flat[g*GRU_UNITS*DATA_WIDTH +: GRU_UNITS*DATA_WIDTH]),
                .i_br(i_br_flat[g*DATA_WIDTH +: DATA_WIDTH]),
                .i_Wz_flat(i_Wz_flat[g*INPUT_FEATURES*DATA_WIDTH +: INPUT_FEATURES*DATA_WIDTH]),
                .i_Uz_flat(i_Uz_flat[g*GRU_UNITS*DATA_WIDTH +: GRU_UNITS*DATA_WIDTH]),
                .i_bz(i_bz_flat[g*DATA_WIDTH +: DATA_WIDTH]),
                .i_Wh_flat(i_Wh_flat[g*INPUT_FEATURES*DATA_WIDTH +: INPUT_FEATURES*DATA_WIDTH]),
                .i_Uh_flat(i_Uh_flat[g*GRU_UNITS*DATA_WIDTH +: GRU_UNITS*DATA_WIDTH]),
                .i_bh(i_bh_flat[g*DATA_WIDTH +: DATA_WIDTH]),

                // Concatenate the output hidden states from each cell
                .o_new_hidden_state(o_new_hidden_state_flat[g*DATA_WIDTH +: DATA_WIDTH])
            );
        end
    endgenerate

    // --- FSM Sequential Logic ---
    always @(posedge clk or negedge rstn) begin
        if (!rstn) begin
            state <= S_IDLE;
            start_cells <= 1'b0;
            o_done <= 1'b0;
        end else begin
            state <= next_state;
            
            // Pulse start_cells for one cycle when transitioning to S_CALC
            start_cells <= (next_state == S_CALC && state == S_IDLE);
            
            // Set final done signal
            o_done <= (next_state == S_DONE);
        end
    end

    // --- FSM Combinational Logic ---
    always @(*) begin
        next_state = state;
        case (state)
            S_IDLE: begin
                if (i_start) next_state = S_CALC;
            end
            S_CALC: begin
                // After starting the cells, immediately move to the wait state
                next_state = S_WAIT;
            end
            S_WAIT: begin
                // Wait until all cells have asserted their done signal
                if (&cells_done) begin
                    next_state = S_DONE;
                end
            end
            S_DONE: begin
                // Stay in done state until the main controller lowers the start signal
                if (!i_start) next_state = S_IDLE;
            end
            default: next_state = S_IDLE;
        endcase
    end

endmodule